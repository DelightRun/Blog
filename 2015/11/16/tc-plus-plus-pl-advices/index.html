<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      TC++PL Advices | 昌旭的博客 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="昌旭/Changxu">
    
    

    <meta name="description" content="Advices from The C++ Programming Language, 4th Edition.">
<meta property="og:type" content="article">
<meta property="og:title" content="TC++PL Advices | 昌旭的博客">
<meta property="og:url" content="http://changxu.wang/2015/11/16/tc-plus-plus-pl-advices/index.html">
<meta property="og:site_name" content="昌旭的博客">
<meta property="og:description" content="Advices from The C++ Programming Language, 4th Edition.">
<meta property="og:updated_time" content="2016-01-26T03:11:35.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TC++PL Advices | 昌旭的博客">
<meta name="twitter:description" content="Advices from The C++ Programming Language, 4th Edition.">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">昌旭的博客</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          机器学习、编程和数学
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">

    

    <!-- China social icon -->
    <!--
    
      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>

    -->



  </ul>
</nav>



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">TC++PL Advices</h1>

    

    <div class="post-meta">
      <time datetime="2015-11-16" class="post-meta__date date">2015-11-16</time> 

      <span class="post-meta__tags tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/C/">C++</a>, <a class="categories-link" href="/categories/C/TC-PL/">TC++PL</a>
            </font>
          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p>Advices from <em>The C++ Programming Language, 4th Edition</em>.</p>
<a id="more"></a>
<h1 id="Chapter-2-A-Tour-of-C-The-Basics"><a href="#Chapter-2-A-Tour-of-C-The-Basics" class="headerlink" title="Chapter 2 - A Tour of C++: The Basics"></a>Chapter 2 - A Tour of C++: The Basics</h1><ol>
<li>Don’t panic! All will become clear in time. <code>section 2.1</code></li>
<li>You don’t have to know every detail of C++ to write good programs. <code>section 1.3.1</code></li>
<li>Focus on programming techniques, not on language features. <code>section 2.1</code></li>
</ol>
<h1 id="Chapter-3-A-Tour-of-C-Abstraction-Mechanisms"><a href="#Chapter-3-A-Tour-of-C-Abstraction-Mechanisms" class="headerlink" title="Chapter 3 - A Tour of C++: Abstraction Mechanisms"></a>Chapter 3 - A Tour of C++: Abstraction Mechanisms</h1><ol>
<li>Express ideas directly in code. <code>section 3.2</code></li>
<li>Define classes to represent application concepts directly in code. <code>section 3.2</code></li>
<li>Use concrete classes to represent simple concepts and performance-critical components. <code>section 3.2.1</code></li>
<li>Avoid “naked” <code>new</code> and <code>delete</code> operations. <code>section 3.2.1.2</code></li>
<li>Use resource handles and RAII to manage resources. <code>section 3.2.2</code></li>
<li>Use abstract classes as interfaces when complete separation of interface and implementation is needed. <code>section 3.2.2</code></li>
<li>Use class hierarchies to represent concepts with inherent hierarchical structure. <code>section 3.2.4</code></li>
<li>When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance. <code>section 3.2.4</code></li>
<li>Control construction, copy, move, and destruction of objects. <code>section 3.3</code></li>
<li>Return containers by value (relying on move for efficiency). <code>section 3.3.2</code></li>
<li>Provide strong resource safety: that is, never leak anything that you think of as a resource. <code>section 3.3.3</code></li>
<li>Use container, defined as resource handle templates, to hold collections of values of the same type. <code>section 3.4.1</code></li>
<li>Use function templates to represent general algorithms. <code>section 3.4.2</code></li>
<li>Use function objects, including lambdas, to represent policies and actions. <code>section 3.4.3</code></li>
<li>Use type and template aliases to provide a uniform notation for types that may vary among similar types or among implementations. <code>section 3.4.5</code></li>
</ol>
<h1 id="Chapter-4-A-Tour-of-C-Containers-and-Algorithms"><a href="#Chapter-4-A-Tour-of-C-Containers-and-Algorithms" class="headerlink" title="Chapter 4 - A Tour of C++: Containers and Algorithms"></a>Chapter 4 - A Tour of C++: Containers and Algorithms</h1><ol>
<li>Don’t reinvent the wheel, use libraries. <code>section 4.1</code></li>
<li>When you have a choices, prefer the standard library over other libraries. <code>section 4.1</code></li>
<li>Do not think that the standard library is ideal for everything. <code>section 4.1</code></li>
<li>Remember to <code>#include</code> the headers for the facilities you use. <code>section 4.1.2</code></li>
<li>Remember that standard-library facilities are defined in namespace <code>std</code>. <code>section 4.1.2</code></li>
<li>Prefer <code>strings</code>s over C-style strings (a <code>char *</code>). <code>section 4.2</code> <code>section 4.3.2</code></li>
<li>Prefer <code>vector&lt;T&gt;</code>, <code>map&lt;K,T&gt;</code>, and <code>unordered_map&lt;K,T&gt;</code> over <code>T[]</code>. <code>section 4.4</code></li>
<li>Know your standard containers and their tradeoffs. <code>section 4.4</code></li>
<li>Use <code>vector</code> as your default container. <code>section 4.4.1</code></li>
<li>Prefer compact data structures. <code>section 4.4.1.1</code></li>
<li>If in doubt, use a range-checked vector. <code>section 4.4.1.2</code></li>
<li>Use <code>push_back()</code> or <code>back_inserter()</code> to add elements to a container. <code>section 4.4.1</code> <code>section 4.5</code></li>
<li>Use <code>push_back()</code> on a <code>vector</code> rather than <code>realloc()</code> on an array. <code>section 4.5</code></li>
<li>Catch common exceptions in <code>main()</code>. <code>section 4.4.1.2</code></li>
<li>Know your standard algorithms and prefer them over handwritten loops. <code>section 4.5.5</code></li>
<li>If iterator use gets tedious, define container algorithms. <code>section 4.5.6</code></li>
</ol>
<h1 id="Chapter-5-A-Tour-of-C-Concurrency-and-Utilities"><a href="#Chapter-5-A-Tour-of-C-Concurrency-and-Utilities" class="headerlink" title="Chapter 5 - A Tour of C++: Concurrency and Utilities"></a>Chapter 5 - A Tour of C++: Concurrency and Utilities</h1><ol>
<li>Use resource handles to manage resources (RAII). <code>section 5.2</code></li>
<li>Use <code>unique_ptr</code> to refer to objects of polymorphic type. <code>section 5.2.1</code></li>
<li>Use <code>shared_ptr</code> to refer to shared objects. <code>section 5.2.1</code></li>
<li>Use type-safe mechanisms for concurrency. <code>section 5.3</code></li>
<li>Minimize the use of shared data. <code>section 5.3.4</code></li>
<li>Don’t choose shared data for communication because of “efficiency” without thought and preferably not without measurement. <code>section 5.3.4</code></li>
<li>Think in terms of concurrent tasks, rather than threads. <code>section 5.3.5</code></li>
<li>A library doesn’t have to be large or complicated to be useful. <code>section 5.4</code></li>
<li>Time your programs before making claims about efficiency. <code>section 5.4.1</code></li>
<li>You can write code to explicitly depend on properties of types. <code>section 5.4.2</code></li>
<li>Use regular expressions for simple pattern matching. <code>section 5.5</code></li>
<li>Don’t try to do serious numeric computation using only the language, use libraries. <code>section 5.6</code></li>
<li>Properties of numeric types are accessible through <code>numeric_limits</code>. <code>section 5.6.5</code></li>
</ol>
<h1 id="Chapter-6-Types-and-Declarations"><a href="#Chapter-6-Types-and-Declarations" class="headerlink" title="Chapter 6 - Types and Declarations"></a>Chapter 6 - Types and Declarations</h1><ol>
<li>For the final word on language definition issues, see the ISO C++ standard. <code>section 6.1</code></li>
<li>Avoid unspecified and undefined behavior. <code>section 6.1</code></li>
<li>Isolate code that must depend on implementation-defined behavior. <code>section 6.1</code></li>
<li>Avoid unnecessary assumptions about the numeric value of characters. <code>section 6.2.3.2</code> <code>section 10.5.2.1</code></li>
<li>Remember that an integer starting with a <code>0</code> is octal. <code>section 6.2.4.1</code></li>
<li>Avoid “magic constants”. <code>section 6.2.4.1</code></li>
<li>Avoid unnecessary assumptions about the size of integers. <code>section 6.2.8</code></li>
<li>Avoid unnecessary assumptions about the range and precision of floating-point types. <code>section 6.2.8</code></li>
<li>Prefer plain <code>char</code> over <code>signed char</code> and <code>unsigned char</code>. <code>section 6.2.3.1</code></li>
<li>Beware of conversions between signed and unsigned types. <code>section 6.2.3.1</code></li>
<li>Declare one name (only) per declaration. <code>section 6.3.2</code></li>
<li>Keep common and local names short, and keep uncommon and nonlocal names longer. <code>seciont 6.3.3</code></li>
<li>Avoid similar-looking names. <code>section 6.3.3</code></li>
<li>Name an object to reflect its meaning rather than its type. <code>section 6.3.3</code></li>
<li>Maintain a consistent naming style. <code>section 6.3.3</code></li>
<li>Avoid <code>ALL_CAPS</code> names. <code>section 6.3.3</code></li>
<li>Keep scopes small. <code>section 6.3.4</code></li>
<li>Don’t use the same name in both a scope and an enclosing scope. <code>section 6.3.4</code></li>
<li>Perfer the <code>{}</code>-initializer syntax for declarations with a named type. <code>section 6.3.5</code></li>
<li>Perfer thr <code>=</code> syntax for the initialization in declarations using <code>auto</code>. <code>section 6.3.5</code></li>
<li>Avoid uninitialized variables. <code>section 6.3.5.1</code></li>
<li>Use an alias to define a meaningful name for a built-in type in cases in which the built-in type used to represent a value might change. <code>section 6.5</code></li>
<li>Use an alias to define synonyms for types, use enumerations and classes to define new types. <code>section 6.5</code></li>
</ol>
<h1 id="Chapter-7-Pointers-Arrays-and-References"><a href="#Chapter-7-Pointers-Arrays-and-References" class="headerlink" title="Chapter 7 - Pointers, Arrays, and References"></a>Chapter 7 - Pointers, Arrays, and References</h1><ol>
<li>Keep use of pointers simple and straightforward. <code>section 7.4.1</code></li>
<li>Avoid nontrivial pointer arithmetic. <code>section 7.4</code></li>
<li>Take care not to write beyond the bounds of an array. <code>section 7.4.1</code></li>
<li>Avoid multidimensional arrays, define suitable containers instead. <code>section 7.4.2</code></li>
<li>Use <code>nullptr</code> rather than <code>0</code> or <code>NULL</code>. <code>section 7.2.2</code></li>
<li>Use containers (e.g. <code>vector</code>, <code>array</code> and <code>valarray</code>) rather than built-in (C-style) arrays. <code>section 7.4.1</code></li>
<li>Use <code>string</code> rather than zero-terminated arrays of <code>char</code>. <code>section 7.4</code></li>
<li>Use raw strings for string literals with complicated uses of backslash. <code>section 7.3.2.1</code></li>
<li>Prefer <code>const</code> reference arguments to plain reference arguments. <code>section 7.7.3</code></li>
<li>Use rvalue references (only) for forwarding and move semantics. <code>section 7.7.2</code></li>
<li>Keep pointers that represent ownership inside handle classes. <code>section 7.6</code></li>
<li>Avoid <code>void*</code> except in low-level code. <code>section 7.2.1</code></li>
<li>Use <code>const</code> pointers and <code>const</code> references to express immutablility in interfaces. <code>section 7.5</code></li>
<li>Prefer references to pointers as arguments, except where “no object” is a reasonable option. <code>section 7.7.4</code></li>
</ol>
<h1 id="Chapter-8-Structures-Unions-and-Enumerations"><a href="#Chapter-8-Structures-Unions-and-Enumerations" class="headerlink" title="Chapter 8 - Structures, Unions, and Enumerations"></a>Chapter 8 - Structures, Unions, and Enumerations</h1><ol>
<li>When compactness of data is important, lay out structure data members with larger members before smaller ones. <code>section 8.2.1</code></li>
<li>Use bit-fields to represent hardware-imposed data layouts. <code>section 8.2.7</code></li>
<li>Don’t naively try to optimize memory consumption by packing several values into a single byte. <code>section 8.2.7</code></li>
<li>Use <code>union</code>s to save space (represent alternatives) and never for type conversion. <code>section 8.3</code></li>
<li>Use enumerations to represent sets of named constants. <code>section 8.4</code></li>
<li>Prefer <code>class enum</code>s over “plain” <code>enum</code>s to minimize surprises. <code>section 8.4</code></li>
<li>Define operations on enumerations for safe and simple use. <code>section 8.4.1</code></li>
</ol>
<h1 id="Chapter-9-Statements"><a href="#Chapter-9-Statements" class="headerlink" title="Chapter 9 - Statements"></a>Chapter 9 - Statements</h1><ol>
<li>Don’t declare a variable until you have a value to initialize it with. <code>section 9.3</code> <code>section 9.4.3</code> <code>section 9.5.2</code></li>
<li>Prefer a <code>switch</code>-statement to an <code>if</code>-statement when there is a choice. <code>section 9.4.2</code></li>
<li>Prefer a range-<code>for</code>-statement to a <code>for</code>-statement when there is a choice. <code>section 9.5.1</code></li>
<li>Prefer a <code>for</code>-statement to a <code>while</code>-statement when there is an obvious loop variable. <code>section 9.5.2</code></li>
<li>Prefer a <code>while</code>-statement to a <code>for</code>-statement when there is no obvious loop variable. <code>section 9.5.3</code></li>
<li>Avoid <code>do</code>-statements. <code>section 9.5</code></li>
<li>Avoid <code>goto</code>. <code>section 9.6</code></li>
<li>Keep comments crisp.</li>
<li>Don’t say in comments what can be clearly stated in code. <code>section 9.7</code></li>
<li>State intent in comments. <code>section 9.7</code></li>
<li>Maintain a consistent indentation style. <code>section 9.7</code></li>
</ol>
<h1 id="Chapter-10-Expressions"><a href="#Chapter-10-Expressions" class="headerlink" title="Chapter 10 - Expressions"></a>Chapter 10 - Expressions</h1><ol>
<li>Prefer the standard library to other libraries and to “handcrafted code”. <code>section 10.2.8</code></li>
<li>Use character-level input only when you have to. <code>section 10.2.3</code></li>
<li>When reading, always consider ill-formed input. <code>section 10.2.3</code>4.</li>
<li>Prefer suitable abstractions (class, algorithms, etc.) to direct use of language features (e.g. ints, statements). <code>section 10.2.8</code></li>
<li>Avoid complicated expressions. <code>section 10.3.3</code></li>
<li>If in doubt about operator precedence, parenthesize. <code>section 10.3.3</code></li>
<li>Avoid expressions with undefined order of evaluation. <code>section 10.3.2</code></li>
<li>Avoid narrowing conversions. <code>section 10.5.2</code></li>
<li>Define symbolic constants to avoid “magic constants”. <code>section 10.4.1</code></li>
<li>Avoid narrowing conversions. <code>section 10.5.2</code></li>
</ol>
<h1 id="Chapter-11-Select-Operations"><a href="#Chapter-11-Select-Operations" class="headerlink" title="Chapter 11 - Select Operations"></a>Chapter 11 - Select Operations</h1><ol>
<li>Prefer prefix <code>++</code> over suffix <code>++</code>. <code>section 11.1.4</code></li>
<li>Use resource handles to avoid leaks, premature deletion, and double deletion. <code>section 11.2.1</code></li>
<li>Don’t put objects on the free store if you don’t have to, prefer scoped variables. <code>section 11.2.1</code></li>
<li>Avoid “naked <code>new</code>“ and “naked <code>delete</code>“. <code>section 11.2.1</code></li>
<li>Use RAII. <code>section 11.2.1</code></li>
<li>Prefer a named function object to a lambda if the operation requires comments. <code>section 11.4.2</code></li>
<li>Prefer a named function object to a lambda if the operation is generally useful. <code>section 11.4.2</code></li>
<li>Keep lambdas short. <code>section 11.4.2</code></li>
<li>For maintainability and correctness, be careful about capture by reference. <code>section 11.4.3.1</code></li>
<li>Let the compiler deduce the return type of a lambda. <code>section 11.4.4</code></li>
<li>Use the <code>T{e}</code> natation for construction. <code>section 11.5.1</code></li>
<li>Avoid explicit type conversion (casts). <code>section 11.5</code></li>
<li>When explicit type conversion is necessary, prefer a named cast. <code>section 11.5</code></li>
<li>Consider using a run-time checked cast, such as <code>narrow_cast&lt;&gt;()</code>, for conversion between numeric types. <code>section 11.5</code></li>
</ol>
<h1 id="Chapter-12-Functions"><a href="#Chapter-12-Functions" class="headerlink" title="Chapter 12 - Functions"></a>Chapter 12 - Functions</h1><ol>
<li>“Package” meaningful operations as carefully named function. <code>section 12.1</code></li>
<li>A function should perform a single logical operation. <code>section 12.1</code></li>
<li>Keep functions short. <code>section 12.1</code></li>
<li>Don’t return pointers or references to local variables. <code>section 12.1.4</code></li>
<li>If a function may have to be evaluated at compile time, declare it <code>constexpr</code>. <code>section 12.1.6</code></li>
<li>If a function cannot return, mark it <code>[[noreturn]]</code>. <code>section 12.1.7</code></li>
<li>Use pass-by-value for small objects. <code>section 12.2.1</code></li>
<li>Use pass-by-<code>const</code>-reference to pass large values that you don’t need to modify. <code>section 12.2.1</code></li>
<li>Return a result as a <code>return</code> value rather than modifying an object through an argument. <code>section 12.2.1</code></li>
<li>Use rvalue references to implement move and forwarding. <code>section 12.2.1</code></li>
<li>Pass a pointer if “no object” is a valid alternative (and represent “no object” by <code>nullptr</code>). <code>section 12.2.1</code></li>
<li>Use pass-by-non-<code>const</code>-reference only if you have to. <code>section 12.2.1</code></li>
<li>Use <code>const</code> extensively and consistently. <code>section 12.2.1</code></li>
<li>Assume that a <code>char*</code> or a <code>const char*</code> argument points to a C-style string. <code>section 12.2.2</code></li>
<li>Avoid passing arrays as pointers. <code>section 12.2.2</code></li>
<li>Pass a homogeneous list of unknown length as an <code>initializer_list&lt;T&gt;</code> (or as some other container). <code>section 12.2.3</code></li>
<li>Avoid unspecified numbers of arguments (<code>...</code>). <code>section 12.2.4</code></li>
<li>Use overloading when functions perform conceptually the same task on different types. <code>section 12.3</code></li>
<li>When overloading on integers, provide functions to eliminate common ambiguities. <code>setion 12.3.5</code></li>
<li>Specify preconditions and postconditions for your functions. <code>section 12.4</code></li>
<li>Prefer function objects (including lambdas) adn virtual functions to pointers to functions. <code>section 12.5</code></li>
<li>Avoid macros. <code>section 12.6</code></li>
<li>If you must use macros, use ugly names with lots of capital letters. <code>section 12.6</code></li>
</ol>
<h1 id="Chapter-13-Exception-Handling"><a href="#Chapter-13-Exception-Handling" class="headerlink" title="Chapter 13 - Exception Handling"></a>Chapter 13 - Exception Handling</h1><ol>
<li>Develop an error-handling strategy early in a design. <code>section 13.1</code></li>
<li>Throw an exception to indicate that you cannot perform an assigned task. <code>section 13.1.1</code></li>
<li>Use exceptions for error handling. <code>section 13.1.4.2</code></li>
<li>Use purpose-designed user-defined types as exceptions (not built-in types). <code>section 13.1.1</code></li>
<li>If you for some reason cannot use exceptions, mimic them. <code>section 13.1.5</code></li>
<li>Use hierarchical error handling. <code>section 13.1.6</code></li>
<li>Keep the individual parts of error handling simple. <code>section 13.1.6</code></li>
<li>Don’t try to catch every exception in every function. <code>section 13.1.6</code></li>
<li>Always provide the basic guarantee. <code>section 13.2</code> <code>section 13.6</code></li>
<li>Provide the strong guarantee unless there is a reason not to. <code>section 13.2</code> <code>section 13.6</code></li>
<li>Let a constructor establish an invariant, ant throw if it cannot. <code>section 13.2</code></li>
<li>Release locally owned resources before throwing an exception. <code>section 13.2</code></li>
<li>Be sure that every resource acquired in a constructor is released when throwing an exception in that constructor. <code>section 13.3</code></li>
<li>Don’t use exceptions where more local control structures will suffice. <code>section 13.1.4</code></li>
<li>Use the “Resource Acquisition Is Initialization” and exception handlers to maintain invariant. <code>section 13.5.2.2</code></li>
<li>Minimize the use of <code>try</code>-blocks. <code>section 13.3</code></li>
<li>Not every program needs to be exception-safe. <code>section 13.1</code></li>
<li>Use “Resource Acquisition Is Initialization” and exception handlers to maintain invariants. <code>section 13.5.2.2</code></li>
<li>Prefer proper resource handles to the less structured <code>finally</code>. <code>section 13.3.1</code></li>
<li>Design your error-handling strategy around invariants. <code>section 13.4</code></li>
<li>What can be checked at compile time is usually best checked at compile time (using <code>static_assert</code>). <code>section 13.4</code></li>
<li>Design your error-handling strategy to allow for different levels of checking/enforcement. <code>section 13.4</code></li>
<li>If your function may not throw, declare it <code>noexcept</code>. <code>section 13.5.1.1</code></li>
<li>Don’t use exception specification. <code>section 13.5.1.3</code></li>
<li>Catch exceptions taht may be part of a hierarchy by reference. <code>section 13.5.2</code></li>
<li>Don’t assume that every exception is derived from class <code>exception</code>. <code>section 13.5.2.2</code></li>
<li>Have <code>main()</code> catch and report all exceptions. <code>section 13.5.2.2</code> <code>section 13.5.2.4</code></li>
<li>Don’t destroy information before you have its replacement ready. <code>section 13.6</code></li>
<li>Leave operands in valid states before throwing an exception from an assignment. <code>section 13.2</code></li>
<li>Never let an exception escape from a destructor. <code>section 13.2</code></li>
<li>Keep ordinary code and error-handling code separate. <code>section 13.1.1</code> <code>section 13.1.4.2</code></li>
<li>Beware of memory leaks caused by memory allocated by <code>new</code> not being released in case of an exception. <code>section 13.3</code></li>
<li>Assume that every exception that can be thrown by a function will be thrown. <code>section 13.2</code></li>
<li>A library shouldn’t unilaterally terminate a program. Instead, throw an exception and let a caller decided. <code>section 13.4</code></li>
<li>A library shouldn’t produce diagnostic output aimed at an end user. Instead, throw an exception and let a caller decide. <code>section 13.1.3</code></li>
</ol>
<h1 id="Chapter-14-Namespaces"><a href="#Chapter-14-Namespaces" class="headerlink" title="Chapter 14 - Namespaces"></a>Chapter 14 - Namespaces</h1><ol>
<li>Use namespaces to express logical structure. <code>section 14.3.1</code></li>
<li>Place every nonlocal name, except main(), in some namespace. <code>section 14.3.1</code></li>
<li>Design a namespace so that you can conveniently use it without accidentally gaining access to unrelated namespaces. <code>section 14.3.3</code></li>
<li>Avoid very short names for namespaces. <code>section 14.4.2</code></li>
<li>If necessary, use namespace aliases to abbreviate long namespace names. <code>section 14.4.2</code></li>
<li>Avoid placing heavy notational burdens on users of your namespaces. <code>section 14.2.2</code> <code>section 14.2.3</code></li>
<li>Use separate namespaces for interfaces and implementations. <code>section 14.3.3</code></li>
<li>Use the <code>Namespace::member</code> notation when defining namespace members. <code>section 14.4</code></li>
<li>Use <code>inline</code> namespaces to support versioning. <code>section 14.4.6</code></li>
<li>Use <code>using</code>-directives for transition, for foundational libraries (such as <code>std</code>), or within a local scope. <code>section 14.4.9</code></li>
<li>Don’t put a <code>using</code>-directive in a header file. <code>section 14.2.3</code></li>
</ol>
<h1 id="Chapter-15-Source-Files-and-Programs"><a href="#Chapter-15-Source-Files-and-Programs" class="headerlink" title="Chapter 15 - Source Files and Programs"></a>Chapter 15 - Source Files and Programs</h1><ol>
<li>Use header files to represent interfaces and to emphasize logical structure. <code>section 15.1</code> <code>section 15.3.2</code></li>
<li><code>#include</code> a header in the source file that implements its functions. <code>section 15.3.1</code></li>
<li>Don’t define global entities with the same name and similar-but-different meanings in different translation units. <code>section 15.2</code></li>
<li>Avoid non-inline function definitions in headers. <code>section 15.2.2</code></li>
<li>USe <code>#include</code> only at global scope and in namespaces. <code>section 15.2.2</code></li>
<li><code>#include</code> only complete declarations. <code>section 15.2.2</code></li>
<li>Use include guards. <code>section 15.3.3</code></li>
<li><code>#include</code> C headers in namespaces to avoid global names. <code>section 14.4.9</code> <code>section 15.2.4</code></li>
<li>Make headers self-contained. <code>section 15.2.3</code></li>
<li>Distinguish between users’ interfaces and implementers’ interfaces. <code>section 15.3.2</code></li>
<li>Distinguish between average users’ interfaces and expert users’ interfaces. <code>section 15.3.2</code></li>
<li>Avoid nonlocal objects that require run-time initialization in code intended for use as part of non-C++ programs. <code>section 15.4.1</code></li>
</ol>
<h1 id="Chapter-16-Classes"><a href="#Chapter-16-Classes" class="headerlink" title="Chapter 16 - Classes"></a>Chapter 16 - Classes</h1><ol>
<li>Represent concepts as classes. <code>section 16.1</code></li>
<li>Separate the interface of a class from its implementation. <code>section 16.1</code></li>
<li>Use public data (<code>struct</code>s) only when it really is just data an no invariant is meaningful for the data members. <code>section 16.2.4</code></li>
<li>Define a constructor to handle initialization of objects. <code>section 16.2.5</code></li>
<li>By default declare single-argument constructors <code>explicit</code>. <code>section 16.2.6</code></li>
<li>Declare a member function that does not modify the state of its object <code>const</code>. <code>section 16.2.9</code></li>
<li>A concrete type is the simplest kind of class. Where applicable, prefer a concrete type over more complicated classes and over plain data structures. <code>section 16.3</code></li>
<li>Make a function a member only if it needs direct access to the representation of a class. <code>section 16.3.2</code></li>
<li>Use a namespace to make the association between a class and its helper functions explicit. <code>section 16.3.2</code></li>
<li>Make a member function that doesn’t modify the value of its object a <code>const</code> member function. <code>section 16.2.9.1</code></li>
<li>Make a function that needs access to the representation of a class but needn’t be called for a specific object a <code>static</code> member function. <code>section 16.2.12</code></li>
</ol>
<h1 id="Chapter-17-Construction-Cleanup-Copy-and-Move"><a href="#Chapter-17-Construction-Cleanup-Copy-and-Move" class="headerlink" title="Chapter 17 - Construction, Cleanup, Copy, and Move"></a>Chapter 17 - Construction, Cleanup, Copy, and Move</h1><ol>
<li>Design constructors, assignments, and the destructor as a matched set of operations. <code>section 17.1</code></li>
<li>Use a constructor to establish an invariant for a class. <code>section 17.2.1</code></li>
<li>If a constructor acquires a resource, its class needs a destructor to release the resource. <code>section 17.2.2</code></li>
<li>If a class has a virtual function, it needs a virtual destructor. <code>section 17.2.5</code></li>
<li>If a class does not have a constructor, it can be initialized by memberwise initialization. <code>section 17.3.1</code></li>
<li>Prefer <code>{}</code> initialization over <code>=</code> and <code>()</code> initialization. <code>section 17.3.2</code></li>
<li>Give a class a default constructor if and only if there is a “natural” default value. <code>section 17.3.3</code></li>
<li>If a class is a container, give it an initializer-list construtor. <code>section 17.3.4</code></li>
<li>Initialize members and bases in their order of declaration. <code>section 17.4.1</code></li>
<li>If a class has a reference member, it probably needs copy operations (copy constructor and copy assignment). <code>section 17.4.1.1</code></li>
<li>Prefer member initialization over assignment in a constructor. <code>section 17.4.1.1</code></li>
<li>Use in-class initializers to provie default values. <code>section 17.4.4</code></li>
<li>If a class is a resource handle, it probably needs copy and move operations. <code>section 17.5</code></li>
<li>When writing a copy constructor, be careful to copy every element that needs to be copied (beware of default initializers). <code>section 17.5.1.1</code></li>
<li>A copy operations should provide equivalence and independence. <code>section 17.5.1.3</code></li>
<li>Beware of entangled data structures. <code>section 17.5.1.1</code></li>
<li>Prefer move semantics and copy-on-write to shallow copy. <code>section 17.5.1.3</code></li>
<li>If a class is used as a base class, protect against slicing. <code>section 17.5.1.4</code></li>
<li>If a class needs a copy operation or a destructor, it probably needs a constructor, a destructor, a copy assignment, and a copy constructor. <code>section 17.6</code></li>
<li>If a class has a pointer member, it probably needs a destructor and non-default copy operations. <code>section 17.6.3.3</code></li>
<li>If a class is a resource handle, it needs a constructor, a destructor, and non-default copy operations. <code>section 17.6.3.3</code></li>
<li>If a default constructor, assignment, or destructor is appropriate, let the compiler generate it (don’t rewrite it yourself). <code>section 17.6</code></li>
<li>Be explicit about your invariants, use constructors to establish them and assignments to maintain them. <code>section 17.6.3.2</code></li>
<li>Make sure that copy assignments are safe for self-assignment. <code>section 17.5.1</code></li>
<li>When adding a new member to a class, check to see if there are user-defined constructors that need to be updated to initialize the member. <code>section 17.5.1</code></li>
</ol>
<h1 id="Chapter-18-Operator-Overloading"><a href="#Chapter-18-Operator-Overloading" class="headerlink" title="Chapter 18 - Operator Overloading"></a>Chapter 18 - Operator Overloading</h1><ol>
<li>Define operators primarily to mimic conventional usage. <code>section 18.1</code></li>
<li>Redefine or prohibit copying if the default is not appropriate for a type. <code>section 18.2.2</code></li>
<li>For large operands, use <code>const</code> reference argument types. <code>section 18.2.4</code></li>
<li>For large results, use a move constructor. <code>section 18.2.4</code></li>
<li>Prefer member functions over nonmembers for operations that need access to the representation. <code>section 18.3.1</code></li>
<li>Prefer nonmember functions over members for operations that do not need access to the representation. <code>section 18.3.2</code></li>
<li>Use namespaces to associate helper functions with “their” class. <code>section 18.2.5</code></li>
<li>Use nonmember functions for symetric operators. <code>section 18.3.2</code></li>
<li>Use member functions to express operators that require an lvalue as their left-hand operand. <code>section 18.3.3.1</code></li>
<li>Use user-defined literals to mimic conventional notation. <code>section 18.3.4</code></li>
<li>Provide “<code>set()</code> and <code>get()</code> functions” for a data member only if the fundamental semantics of a class require them. <code>section 18.3.5</code></li>
<li>Be cautious about introducing implicit conversions. <code>section 18.4</code></li>
<li>Avoid value-destroying (“narrowing”) conversions. <code>section 18.4.1</code></li>
<li>Do not define the same conversion as both a constructor and a conversion operator. <code>section 18.4.3</code></li>
</ol>
<h1 id="Chapter-19-Friends-and-Members"><a href="#Chapter-19-Friends-and-Members" class="headerlink" title="Chapter 19 - Friends and Members"></a>Chapter 19 - Friends and Members</h1><ol>
<li>Use <code>operator[]()</code> for subscripting and for selection based on a single value. <code>section 19.2.1</code></li>
<li>Use <code>operator()()</code> for call semantics, for subscripting, and for selection based on multiple values. <code>section 19.2.2</code></li>
<li>Use <code>operator-&gt;()</code> to dereference “smart pointers”. <code>section 19.2.3</code></li>
<li>Prefer prefix <code>++</code> over suffix <code>++</code>. <code>section 19.2.4</code></li>
<li>Define the global <code>operator new()</code> and <code>operator delete()</code> only if you really have to. <code>section 19.2.5</code></li>
<li>Define member <code>operator new()</code> and member <code>operator delete()</code> to control allocation and deallocation of objects of a specific class or hierarchy of classes. <code>section 19.2.5</code></li>
<li>Use user-defined literals to mimic conventional notation. <code>section 19.2.6</code></li>
<li>Place literal operators in separate namespaces to allow selective user. <code>section 19.2.6</code></li>
<li>For nonspecialized uses, prefer the standard <code>string</code> to the result of your own exercises. <code>section 19.3</code></li>
<li>Use a friend function if you need a nonmember function to have access to the representation of a class (e.g. to improve notation or to access the representation of two classes). <code>section 19.4</code></li>
<li>Prefer member functions to friend functions for granting access to the implementation of a class. <code>section 19.4.2</code></li>
</ol>
<h1 id="Chapter-20-Derived-Classes"><a href="#Chapter-20-Derived-Classes" class="headerlink" title="Chapter 20 - Derived Classes"></a>Chapter 20 - Derived Classes</h1><ol>
<li>Avoid type fields. <code>section 20.3.1</code></li>
<li>Access polymorphic objects through pointers and references. <code>section 20.3.2</code></li>
<li>Use abstract classes to focus design on the provision of clean interfaces. <code>section 20.4</code></li>
<li>Use <code>override</code> to make overriding explicit in large class hierarchies. <code>section 20.3.4.1</code></li>
<li>Use <code>final</code> only sparingly. <code>section 20.3.4.2</code></li>
<li>Use abstract classes to specify interfaces. <code>section 20.4</code></li>
<li>Use abstarct classes to keep implementation details out of interfaces. <code>section 20.4</code></li>
<li>A class with a virtual function should have a virtual destructor. <code>section 20.4</code></li>
<li>An abstract class typically doesn’t need a constructor. <code>section 20.4</code></li>
<li>Prefer <code>private</code> members for implementation details. <code>section 20.5</code></li>
<li>Prefer <code>public</code> members for interfaces. <code>section 20.5</code></li>
<li>Use <code>protected</code> members only carefully when really needed. <code>section 20.5.1.1</code></li>
<li>Don’t declare data members <code>protected</code>. <code>section 20.5.1.1</code></li>
</ol>
<h1 id="Chapter-21-Class-Hierarchies"><a href="#Chapter-21-Class-Hierarchies" class="headerlink" title="Chapter 21 - Class Hierarchies"></a>Chapter 21 - Class Hierarchies</h1><ol>
<li>Use <code>unique_ptr</code> or <code>shared_ptr</code> to avoid forgetting to <code>delete</code> objects created using <code>new</code>. <code>section 21.2.1</code></li>
<li>Avoid data members in base classes intended as interfaces. <code>section 21.2.1.1</code></li>
<li>Use abstract classes to express interfaces. <code>section 21.2.2</code></li>
<li>Give an abstract class a virtual destructor to ensure proper cleanup. <code>section 21.2.2</code></li>
<li>Use <code>override</code> to make overriding explicit in large class hierarchies. <code>section 21.2.2</code></li>
<li>Use abstract classes to support interface inheritance. <code>section 21.2.2</code></li>
<li>Use base classes with data members to support implementation inheritance. <code>section 21.2.2</code></li>
<li>Use ordinary multiple inheritance to express a union of features. <code>section 21.3</code></li>
<li>Use multiple inheritance to separate implementation from interface. <code>section 21.3</code><br>10 Use a virtual base to represent something common to some, but not all, classes in a hierarchy. <code>section 21.3.5</code></li>
</ol>
<h1 id="Chapter-22-Run-Time-Type-Information"><a href="#Chapter-22-Run-Time-Type-Information" class="headerlink" title="Chapter 22 - Run-Time Type Information"></a>Chapter 22 - Run-Time Type Information</h1><ol>
<li>Use virtual functions to ensure that the same operation is performed independently of which interface is used for an object. <code>section 22.1</code></li>
<li>Use <code>dynamic_cast</code> where class hierarchy navigation is unavoidable. <code>section 22.2</code></li>
<li>Use <code>dynamic_cast</code> for type-safe explicit navigation of a class hierarchy. <code>section 22.2.1</code></li>
<li>Use <code>dynamic_cast</code> to a reference type when failure to find the required class is considered a failure. <code>section 22.2.1.1</code></li>
<li>Use <code>dynamic_cast</code> to a pointer type when failure to find the required class is considered a valid alternative. <code>section 22.2.1.1</code></li>
<li>Use double dispatch or the visitor pattern to express operations on two dynamic types (unless you need an optimized lookup). <code>section 22.3.1</code></li>
<li>Don’t call virtual functions during construction or destruction. <code>section 22.4</code></li>
<li>Use <code>typeid</code> to implement extended type information. <code>section 22.5.1</code></li>
<li>Use <code>typeid</code> to find the type of an object (and not to find an interface to an object). <code>section 22.5</code></li>
<li>Prefer virtual functions to repeated <code>switch</code>-statements based on <code>typeid</code> or <code>dynamic_cast</code>. <code>section 22.6</code></li>
</ol>
<h1 id="Chapter-23-Templates"><a href="#Chapter-23-Templates" class="headerlink" title="Chapter 23 - Templates"></a>Chapter 23 - Templates</h1><ol>
<li>Use templates to express algorithms that apply to many argument types. <code>section 23.1</code></li>
<li>Use templates to express containers. <code>section 23.2</code></li>
<li>Note that <code>template&lt;class T&gt;</code> and <code>template&lt;typename T&gt;</code> are synonymous. <code>section 23.2</code></li>
<li>When defining a template, first design and debug a non-template version, later generatlize by adding parameters. <code>section 23.2.1</code></li>
<li>Templates are type-safe, but checking happens too late. <code>section 23.3</code></li>
<li>When designing a template, carefully consider the concepts (requirements) assumed for its template arguments. <code>section 23.3</code></li>
<li>If a class template should be copyable, give it a non-template copy constructor and a non-template copy assignment. <code>section 23.4.6.1</code></li>
<li>If a class template should be movable, give it a non-template move constructor and a non-template move assignment. <code>section 23.4.6.1</code></li>
<li>A virtual function member cannot be a template member function. <code>section 23.4.6.2</code></li>
<li>Define a type as a member of a template only if it depends on all the class template’s arguments. <code>section 23.4.6.3</code></li>
<li>Use function templates to deduce class template argument types. <code>section 23.5.1</code></li>
<li>Overload function templates to get the same semantics for a variety of argument types. <code>section 23.5.3</code></li>
<li>Use argument substitution failure to provide just the right set of functions for a program. <code>section 23.5.3.2</code></li>
<li>Use teplate aliases to simplify notation and hide implementation details. <code>section 23.6</code></li>
<li>There is no separate compilation of templates: <code>#include</code> template definitions in every translation unit that uses them. <code>section 23.7</code></li>
<li>Use ordinary functions as interfaces to code that cannot deal with templates. <code>section 23.7.1</code></li>
<li>Separately compile large templates and templates with nontrivial context dependencies. <code>section 23.7</code></li>
</ol>
<h1 id="Chapter-24-Generic-Programming"><a href="#Chapter-24-Generic-Programming" class="headerlink" title="Chapter 24 - Generic Programming"></a>Chapter 24 - Generic Programming</h1><ol>
<li>A template can pass argument types without loss of information. <code>section 24.1</code></li>
<li>Templates provide a general mechanism for compile-time programming. <code>section 24.1</code></li>
<li>Templates provide compile-time “duck typing”. <code>section 24.1</code></li>
<li>Design generic algorithms by “lifting” from concrete examples. <code>section 24.2</code></li>
<li>Generalize algorithms by specifying template argument requirements in terms of concepts. <code>section 24.3</code></li>
<li>Do not give unconventional meaning to conventional notation. <code>section 24.3</code></li>
<li>Use concepts as a design tool. <code>section 24.3</code></li>
<li>Aim for “plug comatibility” among algorithms and argument type by using common and regular template argument requirements. <code>section 24.3</code></li>
<li>Discover a concept by minimizing an algorithm’s requirements on its template arguments and then generalizing for wider use. <code>section 24.3.1</code></li>
<li>A concept is not just a description of the needs of a particular implementation of an algorithm. <code>section 24.3.1</code></li>
<li>If possible, choose a concept from a list of well-known concepts. <code>section 24.3.1</code> <code>section 24.4.4</code></li>
<li>The default concept for a template argument is <code>Regular</code>. <code>section 24.3.1</code></li>
<li>Not all template argument types are <code>Regular</code>. <code>section 24.3.1</code></li>
<li>A concept requires a semantic aspect, it is not primarily a syntactic notion. <code>section 24.3.1</code> <code>section 24.3.2</code></li>
<li>Make concepts concrete in code. <code>section 24.4</code></li>
<li>Express concepts as compile-time predicates (<code>constexpr</code> functions) and test them using <code>static_assert()</code> or <code>enable_if&lt;&gt;</code>. <code>section 24.4</code></li>
<li>Use axioms as a design tool. <code>section 24.4.1</code></li>
<li>Use axioms as a guide for testing. <code>section 24.4.1</code></li>
<li>Some concepts involve two or more template arguments. <code>section 24.4.2</code></li>
<li>Concepts are not just types of types. <code>section 24.4.2</code></li>
<li>Concepts can involve numeric values. <code>section 24.4.3</code></li>
<li>Use concepts as a guide for testing template definitions. <code>section 24.4.5</code></li>
</ol>
<h1 id="Chapter-25-Specialization"><a href="#Chapter-25-Specialization" class="headerlink" title="Chapter 25 - Specialization"></a>Chapter 25 - Specialization</h1><ol>
<li>Use templates to improve type safety. <code>section 25.1</code></li>
<li>Use templates to raise the level of abstraction of code. <code>section 25.1</code></li>
<li>Use templates to provide flexible and efficient parameterization of types and algorithms. <code>section 25.1</code></li>
<li>Remember that value template arguments must be compile-time constants. <code>section 25.2.2</code></li>
<li>Use function objects as type arguments to parameterize types and algorithms with “policies”. <code>section 25.2.3</code></li>
<li>Use default template arguments to provide simple notation for simple uses. <code>section 25.2.5</code></li>
<li>Specialize templates for irregular types (such as arrays). <code>section 25.3</code></li>
<li>Specialize templates to optimize for important cases. <code>section 25.3</code></li>
<li>Define the primary template before any specialization. <code>section 25.3.1.1</code></li>
<li>A specialization must be in scope for every use. <code>section 25.3.1.1</code></li>
</ol>

  </section>

  

<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'changxusblog'; 
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
